function N = oneoverf3d(e, r, c, p)%% ONEOVERF3D - returns a volume of 1/f noise%% usage:%	ONEOVERF3D(a, n) returns a cube 3D array%	of noise with a 1/(f^a) amplitude spectum%	ONEOVERF(a, m, n, p) returns an m-by-n-by-p array%% see also: spike, oneoverf, spike3d%% Lawrence K. Cormack% history:% 11/12/2002    lkc     There seems to be an orientation bias when the array size is odd.%                       The called function spike() is centering its peak correctly vis-a-vis %                       the shifted Fourier transform, yet the bias remains... Perhaps this is%                       an inherent short coming of the fft algorithm.%                       at any rate, I'm adding a cludge to pad up to the next even pixel and %                       then trim.% 11/12/2000    lkc     cleaned it up % 3/4/01        lkc     added variable exponent% 3/30/2002     lkc     lept into the third dimension% 4/1/02        lkc     exponent is now handled in spike()% 4/1/02        lkc     changed the way the spectrum is generated to the more intuitive%                       amp/phase based-method, but it makes no functional difference.% 3/4/01:  added variable exponent%*** deal with oddity *********codd = 0; rodd = 0; podd = 0;if nargin==2     c=r;    p=r;endif isodd(c)	c=c+1;	codd = 1;endif isodd(r)	r=r+1;	rodd = 1;endif isodd(p)	p=p+1;	podd = 1;end%******************************%*** get array containing 1/f^a falloff ***skirt = spike3d(e, r, c, p);	%*** make noise in f domain and scale the amplitudesN = skirt.*(randn(r, c, p) + i.*randn(r, c, p));%N = skirt.*exp(i.*2.*pi.*rand(r, c, p));	% new way of makin' bacon%  it looks like all this normalization was for naught% the problem was in spike %*** now allow for the over-representation of high-freq bins% y = linspace(-r./2, r./2, r);% x = linspace(-c./2, c./2, c);% z = linspace(-p./2, p./2, p);% [X, Y, Z] = meshgrid(x, y, z);% dists = sqrt(X.^2 + Y.^2 + Z.^2);% area_norms = 4.*pi.*dists.^2;     % for a sphere% area_norms = 8.*(3.*dists.^2 - 3.*dists +1);    % for a cube% area_norms = ones(size(dists));% area_norms = dists;  % correct for a = 1/root(2);% area_norms = dists.^2; % seems correct for alpha = 2% area_norms = dists.^2 - dists;%N = N./area_norms;% clear x y z X Y Z dists;%*** transform to space domainN=real(ifftn(fftshift(N)));%*** normalize to 0-1 ***mn = min(min(min(N)));N = N - mn;mx = (max(max(max(N))));N=N./mx;%*** deal with oddity again ***if codd N(r,:,:) = []; endif rodd N(:,c,:) = []; endif podd N(:,:,p) = []; end%******************************% *************************************** the end